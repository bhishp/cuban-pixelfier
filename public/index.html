<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      }

      h1 {
        margin: 0
      }

      .container {
        display: flex;
        flex-direction: column;
        margin: 16px 0;
        align-items: center;
        gap: 24px
      }

      #canvas {
        /*border: 1px solid black;*/
      }

      #square {
        border: 1px solid black;
        width: 160px;
        height: 160px;
        color: white;
      }
    </style>
</head>
<body>
<div class="container">
    <h1>Pixelfier</h1>
    <!--    <canvas id="canvas" width="3532" height="3532"></canvas>-->
    <img id="cubanTmplImg" src="img/cuban-tmpl.jpg" alt="Crypto Cuban Template" width="400px"/>
    <canvas id="canvas" width="400" height="400"></canvas>
    <div id="square"></div>
</div>
</body>
<script>
  // note, raw img size is 3532x3532
  // TODO: Extract to scriptfile
  const execute = () => {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const cubanTmplImg = document.getElementById('cubanTmplImg');
    if (!cubanTmplImg) {
      return;
    }
    // so, working on 4x4 blocks means we get 100x100 grid pixel
    const imgWidth = 400;
    const pixelWidth = 16; // 8 is best
    const pixelSize = pixelWidth * pixelWidth;
    const horizontalBlockCount = imgWidth / pixelWidth; // how many blocks across? (same down as we're a square img)

    ctx.drawImage(cubanTmplImg, 0, 0, imgWidth, imgWidth);
    cubanTmplImg.style.display = 'none'; // if we want to hide the src image

    const redrawPixels = (dx, dy) => {
      console.log('redrawPixels')
      const pickedSquare = ctx.getImageData(dx, dy, pixelWidth, pixelWidth);

      const rgbaTotals = pickedSquare.data.reduce((acc, curr, idx) => {
        const rgbaIdx = idx % 4;
        return [
          ...acc.slice(0, rgbaIdx),
          acc[rgbaIdx] + curr,
          ...acc.slice(rgbaIdx + 1)
        ];
      }, [0, 0, 0, 0]);
      const avgRgba = rgbaTotals.map(tot => Math.floor(tot / pixelSize));
      const redFactor = 1.2;
      const greenFactor = 1.8;
      const blueFactor = 0.6;
      const redify = ([r, g, b, a]) => [Math.min(r * redFactor, 255), g, b, a];
      const greenish = ([r, g, b, a]) => [r, Math.min(g * greenFactor, 255), b, a];
      const deblue = ([r, g, b, a]) => [r, g, Math.min(b * blueFactor, 255), a];

      const redified = deblue(greenish(redify(avgRgba)));

      // draw the new square back to the image
      const newData = Uint8ClampedArray.from(new Array(pixelSize).fill(redified).flat());
      const newPixel = new ImageData(newData, pixelWidth, pixelWidth);
        ctx.putImageData(newPixel, dx, dy);
      // setTimeout(() => {
      // }, 600);
    }

    let dx = 0;
    let dy = 0;

    setTimeout(() => {
      while (dx < imgWidth) {
        console.log({ dx });
        while (dy < imgWidth) {
          console.log({ dy })
          redrawPixels(dx, dy);
          dy = dy + pixelWidth;
        }
        dx = dx + pixelWidth;
        dy = 0;
      }
    }, 1000);

    // render the avg on-screen
    // const squareEl = document.getElementById('square');
    // const pixelColor = `rgba(${avgRgba[0]}, ${avgRgba[1]}, ${avgRgba[2]}, ${avgRgba[3] / 255})`;
    // squareEl.style.backgroundColor = pixelColor;
    // squareEl.textContent = pixelColor;
  }

  window.onload = () => {
    execute();
  };


</script>
</html>
