<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://cdn.jsdelivr.net/npm/faker@5.5.3/dist/faker.min.js"></script>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      }

      h1 {
        margin: 0
      }

      .container {
        display: flex;
        flex-direction: column;
        margin: 16px 0;
        align-items: center;
        gap: 24px
      }

      #canvas {
        /*border: 1px solid black;*/
      }

      #seed {
        width: 80%;
        height: 80%;
        background-color: #fff;
        color: #000;
        font-size: 24px;
        font-weight: bold;
        text-align: center;
        padding: 16px;
        border: 1px solid #000;
        border-radius: 4px;
      }
      #seed:disabled {
        background: #dddddd;
      }

      button {
        text-align: center;
        padding: 8px;
        border: 1px solid #000;
        border-radius: 4px;
      }
    </style>
</head>
<body>
<div class="container">
    <h1>Pixelfier</h1>
    <!--    <canvas id="canvas" width="3532" height="3532"></canvas>-->
    <img id="cubanTmplImg" src="img/cuban-tmpl.jpg" alt="Crypto Cuban Template" width="400px"/>
    <canvas id="canvas" width="400" height="400"></canvas>
    <input id="seed" type="text" value="CryptoCubanSocialClub" />
    <button id="copySeedButton">Copy Seed</button>
</div>
</body>
<script>
  // ideas
  // 1 - all pixels are jumbled in a mixed up grid, then the grid is sorted to represent the guy, then it turns into a pixel character
  // 2 - the grid sweeps across and then starts re-ordering the pixels into totally random positions, making abstract art
  // 2a - the grid doesn't actually stay uniform, but elongates in ways to make abstract art ( a bit like a mondrian)

  // TODO: Make sure that functions take thing as params going forwards
  // so, working on 4x4 blocks means we get 100x100 grid pixel
  const imgWidth = 400;
  const pixelWidth = 80; // 16 is best
  const blockSize = pixelWidth * pixelWidth;

  // TODO: Add a 'seed random' number
  // - gives the impression of being random but it is actually generated from a seed
  // - what are the dynamic things?
  //    jumbled grid
  //    crawler count
  //    crawler steps (is this possible? Yeah, probably, even if we generate a random direction from a seed we can salt it on each decision anyway)
  //    crawler start loc
  //    crawler speed
  // I'm thinking...
  // - if all the crawlers are deterministic in their direction then even try/fails of moves will still always end up the same evntually

  // an example for staged crawl speed, speeds = [50, 100, 150, 1000] (ms). Random number just picks one from this index
  // Feels like we might need something like `function generateSeededNumber(min, max) => 'a number based on seed between these values'`

  // - what are the things we want to be different per runs? Probably just the jumble matrix and the snake crawl
  // TOOLSET

  // A block is a square collection of pixels
  // Each block is an ImageData object, built up of a Unit8ClampedArray representing the RGBA of each pixel in that block

  // https://stackoverflow.com/a/2450976
  const shuffle = (array) => {
    let currentIndex = array.length,  randomIndex;

    // While there remain elements to shuffle...
    while (currentIndex !== 0) {

      // Pick a remaining element...
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex--;

      // And swap it with the current element.
      [array[currentIndex], array[randomIndex]] = [
        array[randomIndex], array[currentIndex]];
    }

    return array;
  }

  /**
   * Given an array representation of pixels, return the average RGBA for all those pixels
   * [1, 1, 3, 255, 3, 3, 3, 255] → [2, 2, 2, 255]
   * @param pixelArray an array of pixels, returned from imageData.data
   * @param blockSize the size of the block, in pixels (e.g. 4 for a 4x4 block of pixels)
   */
  const calculateBlockAvg = (pixelArray, blockSize) => {
    const rgbaTotals = pixelArray.reduce((acc, curr, idx) => {
      const rgbaIdx = idx % 4;
      return [
        ...acc.slice(0, rgbaIdx),
        acc[rgbaIdx] + curr,
        ...acc.slice(rgbaIdx + 1)
      ];
    }, [0, 0, 0, 0]);
    return rgbaTotals.map(tot => Math.floor(tot / blockSize));
  }

  /**
   * Given a single pixel definition [r, g, b, a], extrapolate that to fill an entire block with the same pixel
   * [1, 2, 3, 255] → [1, 2, 3, 255, 1, 2, 3, 255, 1, 2, 3, 255, 1, 2, 3, 255, 1, 2, 3, 255, 1, 2, 3, 255]
   * @param pixel a single pixel definition in rgba format
   * @param blockSize the size of the block, in pixels (e.g. 4 for a 4x4 block of pixels)
   */
  const extrapolatePixelToBlock = (pixel, blockSize) => {
    return new Uint8ClampedArray(
      new Array(blockSize).fill(pixel).flat()
    );
  }

  /**
   * Split the image into a 2d array of ImageData objects, where each object is a pixelWidth block
   */
  const blockifyImg = (ctx) => {
    const blockMatrix = [];

    let dx = 0;
    let dy = 0;

    while (dx < imgWidth) {
      const subArr = [];
      blockMatrix.push(subArr); // add a new sub-array for y
      while (dy < imgWidth) {

        // pull out parts of the image in blocks
        const block = ctx.getImageData(dx, dy, pixelWidth, pixelWidth);
        subArr.push(block);
        dy = dy + pixelWidth;
      }
      dx = dx + pixelWidth;
      dy = 0;
    }

    return blockMatrix;
  }

  /**
   * Given a blockMatrix - a 2d array of ImageData objects, transform this into a pixelated representation
   * @param blockMatrix
   */
  const pixelate = (blockMatrix) => {
    const pixelatedMatrix = [];
    for(let i = 0; i < blockMatrix.length; i++) {
      const subArr = [];
      pixelatedMatrix.push(subArr);
      for(let j = 0; j < blockMatrix[i].length; j++) {
        const block = blockMatrix[i][j];
        const avg = calculateBlockAvg(block.data, blockSize);
        const blockArray = extrapolatePixelToBlock(avg, blockSize);
        subArr.push(new ImageData(blockArray, pixelWidth, pixelWidth));
      }
    }

    return pixelatedMatrix;
  }

  const invertBlockMatrix = (blockMatrix) => {
    const newMatrix = [];
    for(let i = 0; i < blockMatrix.length; i++) {
      const subArr = [];
      newMatrix.push(subArr);
      for(let j = 0; j < blockMatrix[i].length; j++) {
        subArr.push(blockMatrix[blockMatrix.length - i -1][blockMatrix[i].length - j -1]);
      }
    }
    return newMatrix;
  }

  const jumbleGrid = (blockMatrix) => {
    const newMatrix = [];
    for(let i = 0; i < blockMatrix.length; i++) {
      const subArr = [];
      newMatrix.push(subArr);
      for(let j = 0; j < blockMatrix[i].length; j++) {
        const randIdx = Math.floor(Math.random() * blockMatrix.length);
        const randSubIdx = Math.floor(Math.random() * blockMatrix[i].length);
        subArr.push(blockMatrix[randIdx][randSubIdx]);
      }
    }
    return newMatrix;
  }

  // TODO might need a final class, App, which will generate the Grid, allow it to map to Pixels
  // And manage spawning of more crawlers as it needs

  class Grid {
    #ctx;
    #imageDataMatrix;
    #fillState;
    #crawlers = [];

    // TODO: Could have a spawn configuration (should it spawn more crawlers when they end? Does it maintain a consistent crawler count)
    constructor(ctx, imageDataMatrix) {
      this.#ctx = ctx;
      this.#imageDataMatrix = imageDataMatrix;
      this.#fillState = this.#generateFalseMatrix(imageDataMatrix);
    }

    /**
     * Generate a matrix of false values the same size as the imageDataMatrix
     * @param matrix
     * @returns {*[]}
     */
    #generateFalseMatrix = (matrix) => {
      const fillState = [];
      for(let i = 0; i < matrix.length; i++) {
        const subArr = [];
        fillState.push(subArr);
        for(let j = 0; j < matrix[i].length; j++) {
          subArr.push(false);
        }
      }
      return fillState;
    }

    canMove(x, y) {
      // cannot move outside the bounds of the matrix
      if (x < 0 || x >= this.size.x || y < 0 || y >= this.size.y) {
        return false;
      }

      // cannot move into a filled block
      if (this.#fillState[x][y] === true) {
        return false;
      }

      // cannot move into a spot occupied by another crawler
      return !this.#crawlers.some(({ loc }) => loc.x === x && loc.y === y);
    }

    addCrawler = (x, y) => {
      this.#crawlers.push(new PixelCrawler(this.#ctx, this, x, y));
    }

    initiateCrawlers = () => {
      this.#crawlers.forEach(crawler => crawler.initiate());
    }

    get size() {
      return {
        x: this.#imageDataMatrix.length,
        y: this.#imageDataMatrix[0].length
      }
    }

    draw = (x, y) => {
      if (this.#fillState[x][y]) {
        console.error('already filled this block, return false;')
        return false;
      }
      const block = this.#imageDataMatrix[x][y];
      // TODO: Scope the pixelWidth to the class
      this.#ctx.putImageData(block, x * pixelWidth, y * pixelWidth);
      this.#fillState[x][y] = true;
      return true;
    }
  }

  class PixelCrawler {
    #ctx;
    #grid;
    #x;
    #y;
    #isCrawling = false;
    #name = faker.name.firstName();

    constructor(ctx, grid, x = 0, y = 0) {
      this.#ctx = ctx;
      this.#grid = grid;
      this.#x = x;
      this.#y = y;
    }

    get loc() {
      return {
        x: this.#x,
        y: this.#y
      }
    }

    #log = (msg) => {
      console.debug(`Crawler-${this.#name}: ${msg}`);
    }

    tryMove = (x, y) => {
      if (this.#grid.canMove(x, y)) {
        this.#log(`CAN move to ${x}, ${y}`);
        this.#x = x;
        this.#y = y;
        return true;
      }
      this.#log(`canNOT move to ${x}, ${y}`);
      return false;
    }

    moveUp = () => this.tryMove(this.#x, this.#y - 1);
    moveDown = () => this.tryMove(this.#x, this.#y + 1);
    moveLeft = () => this.tryMove(this.#x - 1, this.#y);
    moveRight = () => this.tryMove(this.#x + 1, this.#y);

    /**
     * Try to move in each direction, if not, return false
     * @returns {boolean}
     */
    move = () => {
      // TODO: First things first, let's get the try order randomised each time
      // use jumble array, we'll sort it out later

      // TODO: a deterministic way this could work is something like this..
      // the seed allows us to generate a list of 0,1,2,3 in "random" order
      // then, each time we call move, it rotates the array in a deterministic way
      // e.g. rot + 1, then rot + 2, then rot + 3, then back to + 1
      // e.g.:
      // - seed generates [4,2,1,3]
      // - call move, try that order
      // - next run we try [3,4,2,1] (rot 1)
      // - next run we try [2,1,3,4] (rot 2)
      // - next run we try [1,3,4,2] (rot 3)
      // - next run we try [1,3,4,2] (rot 4)
      // then start again

      const seed = Math.random();
      this.#log(`call move: ${seed}`);
      const directions = [this.moveUp, this.moveDown, this.moveLeft, this.moveRight];
      return shuffle(directions).some(fn => fn());
    }

    draw = () => {
      return this.#grid.draw(this.#x, this.#y);
    }

    initiate = () => {
      if (this.#isCrawling) {
        return;
      }
      let intervalId;
      // crawling consists of trying to draw the block, and move
      // if there is nowhere to the move then we stop crawling
      const crawl = () => {
        this.#log('crawl n draw');
        this.draw();
        if(!this.move()) {
          this.#log("couldn't move, stopped crawling");
          clearInterval(intervalId);
        }
      }
      crawl();
      intervalId = setInterval(crawl, 200);
    }
  }


  // TODO: Add to reqts, use a seed phrase to give a predictable result
  // So, "Crytpo Cubans are the best". Each component that makes a decision (such as the snake) will use the phrase to make its decision
  // in a predictable manner. We probably sha the phrase or something
  // Allow a user to type any phrase, or press a button to use faker to auto-gen a phrase

  const sleep = async (ms = 20) => {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  const drawBlockMatrix = async (ctx, blockMatrix) => {
    for(let i = 0; i < blockMatrix.length; i++) {
      for(let j = 0; j < blockMatrix[i].length; j++) {
        const block = blockMatrix[i][j];
        await sleep();
        ctx.putImageData(block, i * pixelWidth, j * pixelWidth);
      }
    }
  }

  // const redify = ([r, g, b, a]) => [Math.min(r * redFactor, 255), g, b, a];
  // const greenish = ([r, g, b, a]) => [r, Math.min(g * greenFactor, 255), b, a];
  // const deblue = ([r, g, b, a]) => [r, g, Math.min(b * blueFactor, 255), a];

  // note, raw img size is 3532x3532
  // TODO: Extract to scriptfile
  const execute = async () => {
    const seedInput = document.getElementById('seed');
    const copySeedButton = document.getElementById('copySeedButton');
    let seedValue = seedInput.value;
    seedInput.oninput = () => {
      seedValue = seedInput.value;
    }
    copySeedButton.onclick = () => {
      navigator.clipboard.writeText(seedValue);
    }
    const lockSeed = () => seedInput.disabled = true;

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const cubanTmplImg = document.getElementById('cubanTmplImg');
    if (!cubanTmplImg) {
      return;
    }

    ctx.drawImage(cubanTmplImg, 0, 0, imgWidth, imgWidth);
    cubanTmplImg.style.display = 'none'; // if we want to hide the src image

    let imageMatrix = blockifyImg(ctx);
    imageMatrix = pixelate(imageMatrix);
    imageMatrix = jumbleGrid(imageMatrix);

    const grid = new Grid(ctx, imageMatrix);
    grid.addCrawler(0, 0);
    // grid.addCrawler(10, 10);
    // grid.initiateCrawlers();
  }

  window.onload = () => {
    execute();
  };


</script>
</html>
