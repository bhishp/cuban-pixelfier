<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://cdn.jsdelivr.net/npm/faker@5.5.3/dist/faker.min.js"></script>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      }

      h1 {
        margin: 0
      }

      .container {
        display: flex;
        flex-direction: column;
        margin: 16px 0;
        align-items: center;
        gap: 24px
      }

      #canvas {
        /*border: 1px solid black;*/
      }
    </style>
</head>
<body>
<div class="container">
    <h1>Pixelfier</h1>
    <!--    <canvas id="canvas" width="3532" height="3532"></canvas>-->
    <img id="cubanTmplImg" src="img/cuban-tmpl.jpg" alt="Crypto Cuban Template" width="400px"/>
    <canvas id="canvas" width="400" height="400"></canvas>
</div>
</body>
<script>
  // ideas
  // 1 - all pixels are jumbled in a mixed up grid, then the grid is sorted to represent the guy, then it turns into a pixel character
  // 2 - the grid sweeps across and then starts re-ordering the pixels into totally random positions, making abstract art
  // 2a - the grid doesn't actually stay uniform, but elongates in ways to make abstract art ( a bit like a mondrian)

  // TODO: Make sure that functions take thing as params going forwards
  // so, working on 4x4 blocks means we get 100x100 grid pixel
  const imgWidth = 400;
  const pixelWidth = 80; // 16 is best
  const blockSize = pixelWidth * pixelWidth;

  // TOOLSET

  // A block is a square collection of pixels
  // Each block is an ImageData object, built up of a Unit8ClampedArray representing the RGBA of each pixel in that block

  /**
   * Given an array representation of pixels, return the average RGBA for all those pixels
   * [1, 1, 3, 255, 3, 3, 3, 255] → [2, 2, 2, 255]
   * @param pixelArray an array of pixels, returned from imageData.data
   * @param blockSize the size of the block, in pixels (e.g. 4 for a 4x4 block of pixels)
   */
  const calculateBlockAvg = (pixelArray, blockSize) => {
    const rgbaTotals = pixelArray.reduce((acc, curr, idx) => {
      const rgbaIdx = idx % 4;
      return [
        ...acc.slice(0, rgbaIdx),
        acc[rgbaIdx] + curr,
        ...acc.slice(rgbaIdx + 1)
      ];
    }, [0, 0, 0, 0]);
    return rgbaTotals.map(tot => Math.floor(tot / blockSize));
  }

  /**
   * Given a single pixel definition [r, g, b, a], extrapolate that to fill an entire block with the same pixel
   * [1, 2, 3, 255] → [1, 2, 3, 255, 1, 2, 3, 255, 1, 2, 3, 255, 1, 2, 3, 255, 1, 2, 3, 255, 1, 2, 3, 255]
   * @param pixel a single pixel definition in rgba format
   * @param blockSize the size of the block, in pixels (e.g. 4 for a 4x4 block of pixels)
   */
  const extrapolatePixelToBlock = (pixel, blockSize) => {
    return new Uint8ClampedArray(
      new Array(blockSize).fill(pixel).flat()
    );
  }

  /**
   * Split the image into a 2d array of ImageData objects, where each object is a pixelWidth block
   */
  const blockifyImg = (ctx) => {
    const blockMatrix = [];

    let dx = 0;
    let dy = 0;

    while (dx < imgWidth) {
      const subArr = [];
      blockMatrix.push(subArr); // add a new sub-array for y
      while (dy < imgWidth) {

        // pull out parts of the image in blocks
        const block = ctx.getImageData(dx, dy, pixelWidth, pixelWidth);
        subArr.push(block);
        dy = dy + pixelWidth;
      }
      dx = dx + pixelWidth;
      dy = 0;
    }

    return blockMatrix;
  }

  /**
   * Given a blockMatrix - a 2d array of ImageData objects, transform this into a pixelated representation
   * @param blockMatrix
   */
  const pixelate = (blockMatrix) => {
    const pixelatedMatrix = [];
    for(let i = 0; i < blockMatrix.length; i++) {
      const subArr = [];
      pixelatedMatrix.push(subArr);
      for(let j = 0; j < blockMatrix[i].length; j++) {
        const block = blockMatrix[i][j];
        const avg = calculateBlockAvg(block.data, blockSize);
        const blockArray = extrapolatePixelToBlock(avg, blockSize);
        subArr.push(new ImageData(blockArray, pixelWidth, pixelWidth));
      }
    }

    return pixelatedMatrix;
  }

  const invertBlockMatrix = (blockMatrix) => {
    const newMatrix = [];
    for(let i = 0; i < blockMatrix.length; i++) {
      const subArr = [];
      newMatrix.push(subArr);
      for(let j = 0; j < blockMatrix[i].length; j++) {
        subArr.push(blockMatrix[blockMatrix.length - i -1][blockMatrix[i].length - j -1]);
      }
    }
    return newMatrix;
  }

  const jumbleGrid = (blockMatrix) => {
    const newMatrix = [];
    for(let i = 0; i < blockMatrix.length; i++) {
      const subArr = [];
      newMatrix.push(subArr);
      for(let j = 0; j < blockMatrix[i].length; j++) {
        const randIdx = Math.floor(Math.random() * blockMatrix.length);
        const randSubIdx = Math.floor(Math.random() * blockMatrix[i].length);
        subArr.push(blockMatrix[randIdx][randSubIdx]);
      }
    }
    return newMatrix;
  }

  // TODO might need a final class, App, which will generate the Grid, allow it to map to Pixels
  // And manage spawning of more crawlers as it needs

  class PixelCrawler {
    #ctx;
    #grid;
    #x = 0;
    #y = 0;
    #crawling = false;
    #name = faker.name.firstName();

    constructor(ctx, grid) {
      this.#ctx = ctx;
      this.#grid = grid;
    }

    #log = (msg) => {
      console.debug(`Crawler-${this.#name}: ${msg}`);
    }

    moveUp = () => {
      if (this.#y > 0) {
        this.#y = this.#y - 1;
        return true;
      }
      return false;
    }

    moveDown = () => {
      if (this.#y + 1 < this.#grid.size.y) {
        this.#y = this.#y + 1;
        return true;
      }
      return false;
    }

    moveLeft = () => {
      if (this.#x > 0) {
        this.#x = this.#x - 1;
        return true;
      }
      return false;
    }

    moveRight = () => {
      if (this.#x + 1 < this.#grid.size.x) {
        this.#x = this.#x + 1;
        return true;
      }
      return false;
    }

    // TODO: The bug problem here is that we don't prevent moving, but prevent drawing (this is not the real way to go)
    // Maybe the Grid should hold logic of whether the crawler can move
    // 1. if it hits the wall and 2. if it hits a drawn square
    move = () => {
      // try to move in each direction, if not, return false
      const seed = Math.random();
      console.log('move', seed);
      if (seed < 0.25 && this.moveUp()) {
        console.log('went up')
        return true;
      }
      if (seed < 0.5 && this.moveDown()) {
        console.log('went down')
        return true;
      }
      if (seed < 0.75 && this.moveLeft()) {
        console.log('went left')
        return true;
      }
      if (seed <= 1 && this.moveRight()) {
        console.log('went right')
        return true;
      }
      return false;
    }

    draw = () => {
      return this.#grid.draw(this.#x, this.#y);
    }

    initiateCrawling = () => {
      if (this.#crawling) {
        return;
      }
      let intervalId;
      // crawling consists of trying to draw the block, and move
      // if there is nowhere to the move then we stop crawling
      const crawl = () => {
        console.log('crawl n draw');
        this.draw();
        if(!this.move()) {
          this.#log('couldnt move');
          clearInterval(intervalId);
          console.log('cleared');
        }
      }
      crawl();
      intervalId = setInterval(crawl, 5000);
      // a timeout and then it moves and draws
    }



  }

  // TODO: Next, lets try do the snake painter
  // we need to keep track of the grid state
  // and see what has been painted and what has not
  // and the snake needs to assess all its routes (UP, DOWN, LEFT, RIGHT) and make a decision as to whether it can move or not

  // TODO: Add to reqts, use a seed phrase to give a predictable result
  // So, "Crytpo Cubans are the best". Each component that makes a decision (such as the snake) will use the phrase to make its decision
  // in a predictable manner. We probably sha the phrase or something
  // Allow a user to type any phrase, or press a button to use faker to auto-gen a phrase

  const sleep = async (ms = 20) => {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  const drawBlockMatrix = async (ctx, blockMatrix) => {
    for(let i = 0; i < blockMatrix.length; i++) {
      for(let j = 0; j < blockMatrix[i].length; j++) {
        const block = blockMatrix[i][j];
        await sleep();
        ctx.putImageData(block, i * pixelWidth, j * pixelWidth);
      }
    }
  }

  // const redify = ([r, g, b, a]) => [Math.min(r * redFactor, 255), g, b, a];
  // const greenish = ([r, g, b, a]) => [r, Math.min(g * greenFactor, 255), b, a];
  // const deblue = ([r, g, b, a]) => [r, g, Math.min(b * blueFactor, 255), a];

  // note, raw img size is 3532x3532
  // TODO: Extract to scriptfile
  const execute = async () => {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const cubanTmplImg = document.getElementById('cubanTmplImg');
    if (!cubanTmplImg) {
      return;
    }

    ctx.drawImage(cubanTmplImg, 0, 0, imgWidth, imgWidth);
    cubanTmplImg.style.display = 'none'; // if we want to hide the src image

    let imageMatrix = blockifyImg(ctx);
    imageMatrix = pixelate(imageMatrix);
    imageMatrix = jumbleGrid(imageMatrix);

    class Grid {
      #ctx;
      #imageDataMatrix;
      #fillState;

      #generateEmptyFillState = (matrix) => {
        const fillState = [];
        for(let i = 0; i < matrix.length; i++) {
          const subArr = [];
          fillState.push(subArr);
          for(let j = 0; j < matrix[i].length; j++) {
            subArr.push(false);
          }
        }
        return fillState;
      }

      constructor(ctx, imageDataMatrix) {
        this.#ctx = ctx;
        this.#imageDataMatrix = imageDataMatrix;
        this.#fillState = this.#generateEmptyFillState(imageDataMatrix);
      }

      get size() {
        return {
          x: this.#imageDataMatrix.length,
          y: this.#imageDataMatrix[0].length
        }
      }

      draw = (x, y) => {
        if (this.#fillState[x][y]) {
          console.error('already filled this block, return false;')
          return false;
        }
        const block = this.#imageDataMatrix[x][y];
        // TODO: Scope the pixelWidth to the class
        this.#ctx.putImageData(block, x * pixelWidth, y * pixelWidth);
        this.#fillState[x][y] = true;
        return true;
      }
    }

    const grid2 = new Grid(ctx, imageMatrix);

    const crawler = new PixelCrawler(ctx, grid2);
    // console.log(crawler.moveDown());
    // crawler.initiateCrawling();
    // crawler.draw();
    // crawler.draw();
    // crawler.draw();
    // crawler.draw();

    // const matrix = blockifyImg(ctx);
    // const pixelatedMatrix = pixelate(matrix);
    // await drawBlockMatrix(ctx, jumbleGrid(pixelatedMatrix));
    // drawInverted(ctx, pixelatedMatrix);

    // console.log(matrix[0][0].data);
    // console.log(calculateBlockAvg(matrix[0][0].data, blockSize));
    // console.log(pixelatedMatrix);
    // console.log(pixelatedMatrix[0][0].data);
  }

  window.onload = () => {
    execute();
  };


</script>
</html>
