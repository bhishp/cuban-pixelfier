<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pixelfier</title>
    <script src="https://cdn.jsdelivr.net/npm/faker@5.5.3/dist/faker.min.js"></script>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      }

      h1 {
        margin: 0
      }

      .container,#seedForm {
        display: flex;
        flex-direction: column;
        margin: 16px 0;
        align-items: center;
        gap: 24px
      }
      #seedForm {
        width: 100%;
      }

      #canvas {
        /*border: 1px solid black;*/
      }

      #seed {
        width: 80%;
        height: 80%;
        background-color: #fff;
        color: #000;
        font-size: 24px;
        font-weight: bold;
        text-align: center;
        padding: 16px;
        border: 1px solid #000;
        border-radius: 4px;
      }
      #seed:disabled {
        background: #dddddd;
      }

      button {
        text-align: center;
        padding: 8px;
        border: 1px solid #000;
        border-radius: 4px;
      }
      #startButton {
        background-color: lightgreen;
      }
    </style>
</head>
<body>
<div class="container">
    <h1>Pixelfier</h1>
    <!--    <canvas id="canvas" width="3532" height="3532"></canvas>-->
    <img id="cubanTmplImg" src="img/cuban-tmpl.jpg" alt="Crypto Cuban Template" width="400px"/>
    <canvas id="canvas" width="400" height="400"></canvas>
    <form id="seedForm">
        <input id="seed" type="text" value="CryptoCubanSocialClub" />
        <label>Crawl Speed
            <input type="range" id="crawlSpeed" min="1" max="50" value="50" />
            <span id="crawlSpeedValue" />
        </label>
        <label>Crawler Count
            <input type="range" id="crawlerCount" min="1" max="10" value="3" />
            <span id="crawlerCountValue" />
        </label>
        <label>Block Width
            <input type="number" id="blockWidth" min="1" max="400" value="20" />
        </label>
        <div>
            <button id="startButton">Start</button>
            <button type="submit" id="copySeedButton">Copy Seed</button>
        </div>
    </form>
</div>
</body>
<script>
  /**
   * Access the index in a circular fashion.
   * [0,1,2].circularGet(3) => 0
   * (must be positive)
   */
  Array.prototype.circularGet = function(idx) {
    return this[idx % this.length];
  }

  const IMG_WIDTH = 400;
  const DEFAULT_COLOR_THRESHOLD = 12;

  // ==GLOBAL STATE== because its easy...
  let dCrawlerTimeout = 0;
  let gCrawlerCount = 1;
  let gBlockWidth = 20;

  /**
   * Converts a seed phrase to a sha256 hash. Represented as an array of unsigned 8 bit integers
   * (a 32-length array of 8-bit unsigned integers, ranges from 0 to 255).
   * https://stackoverflow.com/a/48161723
   * @param seed
   */
  const shaSeed = async (seed) => {
    const msgBuffer = new TextEncoder().encode(seed);
    const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
    return Array.from(new Uint8Array(hashBuffer))
  }

  const seededCoords = (a, b, gridWidth) => {
    const x = a % gridWidth;
    const y = b % gridWidth;
    return [x, y];
  }

  const calculateCrawlerTimeout = (speedValue) => 10*(50 - speedValue);

  /**
   * Given a seed array, return an dirPref array (4 length array containing the integers 0,1,2,3 at least and only once)
   * Pass a startIdx to mean the dirPref can be different with the same seed
   */
  const seedDirPref = (seedArray, startIdx) => {
    const FALLBACK_ORDER = [0,1,2,3];
    return [
      ...new Set([
        ...seedArray.map((n, i) => (n + i * startIdx) % 4),
        ...FALLBACK_ORDER
      ])];
  }

  // A block is a square collection of pixels
  // Each block is an ImageData object, built up of a Unit8ClampedArray representing the RGBA of each pixel in that block
  /**
   * Given an array representation of pixels, return the average RGBA for all those pixels
   * [1, 1, 3, 255, 3, 3, 3, 255] → [2, 2, 2, 255]
   * @param pixelArray an array of pixels, returned from imageData.data
   * @param blockSize the size of the block, in pixels (e.g. 4 for a 4x4 block of pixels)
   */
  const calculateBlockAvg = (pixelArray, blockSize) => {
    const rgbaTotals = pixelArray.reduce((acc, curr, idx) => {
      const rgbaIdx = idx % 4;
      return [
        ...acc.slice(0, rgbaIdx),
        acc[rgbaIdx] + curr,
        ...acc.slice(rgbaIdx + 1)
      ];
    }, [0, 0, 0, 0]);
    return rgbaTotals.map(tot => Math.floor(tot / blockSize));
  }

  /**
   * Given a single pixel definition [r, g, b, a], extrapolate that to fill an entire block with the same pixel
   * [1, 2, 3, 255] → [1, 2, 3, 255, 1, 2, 3, 255, 1, 2, 3, 255, 1, 2, 3, 255, 1, 2, 3, 255, 1, 2, 3, 255]
   * @param pixel a single pixel definition in rgba format
   * @param blockSize the size of the block, in pixels (e.g. 4 for a 4x4 block of pixels)
   */
  const extrapolatePixelToBlock = (pixel, blockSize) => {
    return new Uint8ClampedArray(
      new Array(blockSize).fill(pixel).flat()
    );
  }

  /**
   * Split the image into a 2d array of ImageData objects, where each object is a pixelWidth block
   */
  const blockifyImg = (ctx, pixelWidth) => {
    const blockMatrix = [];

    let dx = 0;
    let dy = 0;

    while (dx < IMG_WIDTH) {
      const subArr = [];
      blockMatrix.push(subArr); // add a new sub-array for y
      while (dy < IMG_WIDTH) {

        // pull out parts of the image in blocks
        const block = ctx.getImageData(dx, dy, pixelWidth, pixelWidth);
        subArr.push(block);
        dy = dy + pixelWidth;
      }
      dx = dx + pixelWidth;
      dy = 0;
    }

    return blockMatrix;
  }

  /**
   * Given a blockMatrix - a 2d array of ImageData objects, transform this into a pixelated representation
   */
  const pixelate = (blockMatrix, pixelWidth, palette) => {
    const blockSize = pixelWidth * pixelWidth;
    const pixelatedMatrix = [];
    for(let i = 0; i < blockMatrix.length; i++) {
      const subArr = [];
      pixelatedMatrix.push(subArr);
      for(let j = 0; j < blockMatrix[i].length; j++) {
        const block = blockMatrix[i][j];
        const avg = calculateBlockAvg(block.data, blockSize);
        const colorFromPalette = increasingThresholdCheck(avg, palette, true)[0]; // pick the closest color from the palette
        const blockArray = extrapolatePixelToBlock(colorFromPalette || avg, blockSize);
        subArr.push(new ImageData(blockArray, pixelWidth, pixelWidth));
      }
    }

    return pixelatedMatrix;
  }

  /**
   * Jumble the grid in a 'random' (but deterministic) order
   * Is not actually random but jumbled according to the seed array
   * Updates the imageDataMatrix in-place
   */
  jumbleGrid = (blockMatrix, seedArray) => {
    const newMatrix = [];
    const sizeX = blockMatrix.length;
    const sizeY = blockMatrix[0].length;
    let seedIdx = 0;

    for(let i = 0; i < sizeX; i++) {
      const subArr = [];
      newMatrix.push(subArr);
      for(let j = 0; j < sizeY; j++) {
        const seedValue = seedArray.circularGet(i*seedIdx);
        seedIdx++;

        const x = seedValue % sizeX;
        const y = sizeY - 1 - x;
        subArr.push(blockMatrix[x][y]);
      }
    }
    return newMatrix;
  }

  const invertBlockMatrix = (blockMatrix) => {
    const newMatrix = [];
    for(let i = 0; i < blockMatrix.length; i++) {
      const subArr = [];
      newMatrix.push(subArr);
      for(let j = 0; j < blockMatrix[i].length; j++) {
        subArr.push(blockMatrix[blockMatrix.length - i -1][blockMatrix[i].length - j -1]);
      }
    }
    return newMatrix;
  }

  /**
   * Given two rgba arrays, determine whether the colors are similar
   */
  const colorsAreClose = ([r1, g1, b1, a1], [r2, g2, b2, a2], threshold = DEFAULT_COLOR_THRESHOLD) => {
    const rDiff = Math.abs(r1 - r2);
    const gDiff = Math.abs(g1 - g2);
    const bDiff = Math.abs(b1 - b2);
    const aDiff = Math.abs(a1 - a2);

    const avgDiff = (rDiff + gDiff + bDiff + aDiff) / 4;
    return avgDiff < threshold;
  }

  /**
   * Given a flat pixel array or [r, g, b, a, r2, g2, b2, a2, ...], zip into individual arrays => [[r, g, b, a], [r2, g2, b2, a2], ...]
   */
  const zipPixels = (pixels) => pixels.reduce((acc, curr, i) => {
    const chunkIndex = Math.floor(i / 4);
    if (!acc[chunkIndex]) {
      acc[chunkIndex] = [];
    }
    acc[chunkIndex].push(curr);
    return acc;
  }, []);

  /**
   * Check if there are some similarly-colored pixels in the array and keep increasing the threshold until at least
   * one match is found, or the threhold is too large
   * @param single - return only a single item, or return all similar colors
   */
  const increasingThresholdCheck = (comparator, pixels, single = false, threshold = DEFAULT_COLOR_THRESHOLD) => {
    const matches = single ? [pixels.find(p => colorsAreClose(p, comparator, threshold))]: pixels.filter(p => colorsAreClose(p, comparator, threshold));
    if (matches.length) {
      return matches;
    }
    if (threshold > 256) {
      return [comparator];
    }
    return increasingThresholdCheck(comparator, pixels, false, threshold*2);
  }

  /**
   * Given a zipped array of pixels (2d [r,g,b,a][]), create a simple palette of colors
   * @param pixelsIn
   * @returns {*[]}
   */
  const determinePalette = (pixelsIn) => {
    const palette = [];
    let pixels = JSON.parse(JSON.stringify(pixelsIn));

    // whilst there are pixels left to match with the palette
    while (pixels.length > 0) {
      // if any pixels are close to colors in the existing palette then remove them as we already have a close-enough color
      pixels = pixels.filter(p => !palette.some(pal => colorsAreClose(p, pal)));
      if (!pixels.length) {
        break;
      }

      // from the remaining pixels, pick one to try and find close pixels
      const comparator = pixels.shift();

      // extract close colors
      const closeColors = increasingThresholdCheck(comparator, pixels, false);
      if (closeColors.length) {
        const newPaletteColor = calculateBlockAvg([...comparator, ...closeColors.flat()], closeColors.length + 1);
        palette.push(newPaletteColor);
      }
    }
    return palette;
  }

  /**
   * Read every pixel from the canvas and work out a palette of reduced colours
   * @param ctx
   * @returns {*[]}
   */
  const createPalette = (ctx) => {
    const imgData = ctx.getImageData(0, 0, IMG_WIDTH, IMG_WIDTH);
    const pixels = imgData.data;
    const zippedPixels = zipPixels(pixels);
    return determinePalette(zippedPixels);
  }

  class Grid {
    #ctx;
    #pixelWidth;
    #imageDataMatrix;
    #fillState;
    #crawlers = [];
    #seedArray;
    #hasRun = false;

    constructor(ctx, pixelWidth, imageDataMatrix, seedArray) {
      this.#ctx = ctx;
      this.#pixelWidth = pixelWidth;
      this.#imageDataMatrix = imageDataMatrix;
      this.#fillState = this.#generateFalseMatrix(imageDataMatrix);
      this.#seedArray = seedArray;
      this.seedCrawlers();
    }

    set seedArray(seedArray) {
      this.#seedArray = seedArray;
    }

    get size() {
      return {
        x: this.#imageDataMatrix.length,
        y: this.#imageDataMatrix[0].length
      }
    }

    get pixelWidth() {
      return this.#pixelWidth;
    }

    seedCrawlers = () => {
      for(let i = 0; i < gCrawlerCount; i++) {
        const [x, y] = seededCoords(this.#seedArray[i], this.#seedArray[i + 1], this.size.x);
        this.addCrawler(x, y, i);
      }
    }

    /**
     * Generate a matrix of false values the same size as the imageDataMatrix
     * @param matrix
     * @returns {*[]}
     */
    #generateFalseMatrix = (matrix) => {
      const fillState = [];
      for(let i = 0; i < matrix.length; i++) {
        const subArr = [];
        fillState.push(subArr);
        for(let j = 0; j < matrix[i].length; j++) {
          subArr.push(false);
        }
      }
      return fillState;
    }

    /**
     * Determine if a crawler can move to the given position
     */
    canMove(x, y) {
      // cannot move outside the bounds of the matrix
      if (x < 0 || x >= this.size.x || y < 0 || y >= this.size.y) {
        return false;
      }

      // cannot move into a filled block
      if (this.#fillState[x][y] === true) {
        return false;
      }

      // cannot move into a spot occupied by another crawler
      return !this.#crawlers.some(({ loc }) => loc.x === x && loc.y === y);
    }

    findFreeSpace = () => {
      let freeX = -1;
      let freeY = -1;
      freeX = this.#imageDataMatrix.findIndex((row, x) => {
        freeY = row.findIndex((col, y) => {
          return this.canMove(x, y);
        });
        return freeY !== -1;
      });

      if (freeX !== -1 && freeY !== -1) {
        return [freeX, freeY];
      }
    }

    /**
     * Instantiates a new crawler and adds it to the crawler list
     * i is the index of this crawler as it is added to the grid
     */
    addCrawler = (x, y, i) => {
      if (!this.canMove(x, y)) {
        console.error('Cannot add crawler to invalid location');
        return false;
      }
      const dirPref = seedDirPref(this.#seedArray, i);
      this.#crawlers.push(
        new PixelCrawler(
          this.#ctx,
          this,
          x,
          y,
          dirPref,
          dCrawlerTimeout,
        )
      );
    }

    initiateCrawlers = () => {
      if (!this.#hasRun) {
        this.#hasRun = true;

        // if a crawler gets stuck let's see if there is a free space
        // and teleport them there and start crawling again
        // if no free spaces then we leave it
        const onCrawlerStuck = (crawler) => {
          const freeSpace = this.findFreeSpace();
          if (freeSpace) {
            crawler.tryMove(...freeSpace);
            crawler.initiate(onCrawlerStuck);
          }
        }

        this.#crawlers.forEach(crawler => crawler.initiate(onCrawlerStuck));
      }
    }

    draw = (x, y) => {
      if (this.#fillState[x][y]) {
        console.debug('already filled this block, return false;')
        return false;
      }
      const block = this.#imageDataMatrix[x][y];
      this.#ctx.putImageData(block, x * this.pixelWidth, y * this.pixelWidth);
      this.#fillState[x][y] = true;
      return true;
    }
  }

  class PixelCrawler {
    #ctx;
    #grid;
    #x;
    #y;
    #isCrawling = false;
    gotStuck = false;
    #name = faker.name.firstName();
    #dirPref; // the preference for move direction
    #moveCount = 0;
    #crawlTimeout;

    constructor(ctx, grid, x = 0, y = 0, initialDirPref, crawlTimeout) {
      this.#ctx = ctx;
      this.#grid = grid;
      this.#x = x;
      this.#y = y;
      this.#dirPref = initialDirPref;
      this.#crawlTimeout = crawlTimeout;
      this.#log('crawler constructed');
    }

    get loc() {
      return {
        x: this.#x,
        y: this.#y
      }
    }

    #log = (msg) => {
      console.debug(`Crawler[${this.#name}]: ${msg}`);
    }

    tryMove = (x, y) => {
      if (this.#grid.canMove(x, y)) {
        this.#log(`CAN move to ${x}, ${y}`);
        this.#x = x;
        this.#y = y;
        return true;
      }
      this.#log(`canNOT move to ${x}, ${y}`);
      return false;
    }

    moveUp = () => this.tryMove(this.#x, this.#y - 1);
    moveDown = () => this.tryMove(this.#x, this.#y + 1);
    moveLeft = () => this.tryMove(this.#x - 1, this.#y);
    moveRight = () => this.tryMove(this.#x + 1, this.#y);
    DIRECTIONS = [this.moveUp, this.moveDown, this.moveLeft, this.moveRight]

    #incrementMoveCounter = () => this.#moveCount++;

    /**
     * Rotate the direction preference in order to appear more random
     * Do this by rotating the array in an increasing fashion each time a movement is made
     */
    #rotateDirPref = () => {
      this.#dirPref = this.#dirPref.map((_, i, arr) => arr.circularGet(i + this.#moveCount));
    };
    /**
     * Try to move in each direction, if not, return false
     * @returns {boolean}
     */
    move = () => {
      // map from dirPref to the move functions
      const tryOrder = this.#dirPref.map(idx => this.DIRECTIONS[idx]);
      this.#rotateDirPref();
      this.#incrementMoveCounter();
      // try move at least one direction, return false if nome succeeded
      return tryOrder.some(fn => fn());
    }

    draw = () => {
      return this.#grid.draw(this.#x, this.#y);
    }

    initiate = (onStuck) => {
      if (this.#isCrawling) {
        return;
      }
      let intervalId;
      // crawling consists of trying to draw the block, and move
      // if there is nowhere to the move then we stop crawling
      const crawl = () => {
        this.#log('crawl n draw');
        this.draw();
        if(!this.move()) {
          this.#log("couldn't move, stopped crawling");
          this.gotStuck = true;
          this.#isCrawling = false;
          clearInterval(intervalId);
          onStuck(this);
        }
      }
      crawl();
      intervalId = setInterval(crawl, this.#crawlTimeout);
    }
  }

  // const redify = ([r, g, b, a]) => [Math.min(r * redFactor, 255), g, b, a];
  // const greenish = ([r, g, b, a]) => [r, Math.min(g * greenFactor, 255), b, a];
  // const deblue = ([r, g, b, a]) => [r, g, Math.min(b * blueFactor, 255), a];
  // const saturate = (rgba) => rgba.map(c => Math.min(c * 1.3, 255));

  // note, raw img size is 3532x3532
  const execute = async () => {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const cubanTmplImg = document.getElementById('cubanTmplImg');
    if (!cubanTmplImg) {
      return;
    }

    // DOM
    const seedForm = document.getElementById('seedForm');
    const seedInput = document.getElementById('seed');
    const crawlSpeedInput = document.getElementById('crawlSpeed');
    const crawlSpeedValue = document.getElementById('crawlSpeedValue');
    const crawlerCountInput = document.getElementById('crawlerCount');
    const crawlerCountValue = document.getElementById('crawlerCountValue');
    const blockWidthInput = document.getElementById('blockWidth');
    const copySeedButton = document.getElementById('copySeedButton');
    const startButton = document.getElementById('startButton');

    let seedPhrase = seedInput.value;
    let seedArray = await shaSeed(seedPhrase);
    crawlSpeedValue.textContent = crawlSpeedInput.value;
    dCrawlerTimeout = calculateCrawlerTimeout(crawlSpeedInput.value)
    crawlerCountValue.textContent = crawlerCountInput.value;
    gCrawlerCount = crawlerCountInput.value;
    gBlockWidth = Number.parseInt(blockWidthInput.value);

    seedInput.oninput = async () => {
      seedPhrase = seedInput.value;
      seedArray = await shaSeed(seedPhrase);
    }
    crawlSpeedInput.oninput = () => {
      crawlSpeedValue.textContent = crawlSpeedInput.value;
      dCrawlerTimeout = calculateCrawlerTimeout(crawlSpeedInput.value)
    }
    crawlerCountInput.oninput = () => {
      crawlerCountValue.textContent = crawlerCountInput.value;
      gCrawlerCount = crawlerCountInput.value;
    }
    blockWidthInput.oninput = () => {
      gBlockWidth = Math.min(Number.parseInt(blockWidthInput.value), 400);
    }
    copySeedButton.onclick = () => {
      navigator.clipboard.writeText(seedPhrase);
    }
    const lock = () => {
      seedInput.disabled = true;
      startButton.disabled = true;
    }

    // const pixelWidth = PIXEL_WIDTHS.circularGet(seedArray[0]);
    // const pixelWidth = 20;

    // draw the image to the canvas at a scaled size
    ctx.drawImage(cubanTmplImg, 0, 0, IMG_WIDTH, IMG_WIDTH);
    cubanTmplImg.style.display = 'none'; // if we want to hide the src image

    seedForm.onsubmit = (e) => {
      e.preventDefault();
      lock();
      console.log(seedArray)
      let imageMatrix = blockifyImg(ctx, gBlockWidth);
      const palette = createPalette(ctx);
      imageMatrix = pixelate(imageMatrix, gBlockWidth, palette);
      // imageMatrix = jumbleGrid(imageMatrix, seedArray);
      const grid = new Grid(ctx, gBlockWidth, imageMatrix, seedArray);
      grid.seedArray = seedArray;
      grid.initiateCrawlers();
    }
  }

  window.onload = () => {
    execute();
  };

  // Example seed: [53, 127, 159, 98, 103, 212, 178, 219, 154, 101, 73, 144, 213, 104, 164, 217, 181, 190, 94, 52, 173, 60, 35, 173, 86, 107, 154, 103, 125, 116, 88, 205]
  // TODO-list:
  // - support exporting the image (may need an off-screen canvas if we get a pixelated export)
  // TODO:
  // - then, we're going to change everything to be input based (crawl speed, seed, etc)
  // - then, maybe, output a speed (though, this sounds complex)
  // - consider whether we keep the seeded crawl mechanism
  // - consider supporting new images
  // - exporting image
  // - handle crawl speeds through a map isntead of array
  // - rename it from crawl speed

</script>
</html>
